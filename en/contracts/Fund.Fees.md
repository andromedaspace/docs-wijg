# Fees specification
* Все платежи подразделяются на
    * One Off (Mandatory/Optional) - Единоразовые (обязательные/не обязательные)
    * Regular (Mandatory/Optional) - Повторяющиеся (обязательные/не обязательные)
* В голосовании по принятию платежа указывается фабрика, которая создаст контракт, а так же, параметры для конструктора контракта.
* В каждом фонде на каждый тип/подтип платеж создается отдельный контракт, с определенными правами.
* Платежи со всех контрактов fee отправляются на общий мультисиг.
* Деактивация fee контракта происходит с помощью отдельного типа ProposalManager
* Оплата производится с помощью контракта Controller. При платеже указываются:
    * Адрес контракта платежа
    * Сумма платежа
* Размер минимального платежа не ограничен. Можно делать платежи по 1 wei.
* Контракт Fee должен иметь возможность установить в FundController timestamp, когда возникнет задолженность. Например:
    * Повторяющийся платеж. Сейчас середина периода 42. При оплате за период 41, возникновение задолженности устанавливается на конец периода 42.
* В контракте fundController присутствуют следующие поля, относящиеся к fees:
    * mapping(address => timestamp) closestDebtArise - самый ближайший timestamp возникновения задолженности по конкретному участнику,
        * Контракты fee могут уменьшить это поле как в меньшую так и в большую сторону
            * Если устанавливается в меньшую - никаких операций не требуется
            * Если устанавливается в большую - необходимо пройти по всему списку timestamp всех контрактов и убедится, что пытаемся установить наименьшее значение.
    * mapping(address => mapping(fineContract => timestamp)) closestFineDebtArise - ближайший timestamp возникновения задолженности для участника по конкретному контракту
* Для вывода токена достаточно будет проверить, что timestamp в поле closestDebtArise еще не наступил.

## Regular Fee specification

Конкретная реализация 

### Statements
* Имея изначальный (Ti) и текущий timestamp-ы (Tc) и длину периода в секундах(Ds), можно определить текущий период (Pc):
    * Pc = (Tc - Ti) / Ds
* Оплата учитывается нарастающим итогом, а не не учитывается по каждому конкретному периоду отдельно. Т.е., если не оплачен полностью период 42, период 43 не может быть учтен, и все поступающие платежи сначала будут идти на период 42.
* 
* Если указанная дата начала периода на момент создания контракта уже прошла, участникам необходимо будет оплатить все задолженности, чтобы не возникло блокировки токена участка.
* При создании контракта указываются:
    * Валюта (ETH/ERC20)
    * Адрес контракта в случае ERC20
    * Начальная дата (timestamp)
    * Период в секундах (не может быть изменен)

## TBD

* Добавление новых участников
* Входящий участник платит полностью за последний период?
* Выходящий участник платит полностью за период следующий?
* Какая логика если участник выходит на 3 месяца, потом опять входит?
* Как менять размер платежа?
* Как учитывать опциональные платежи? Нарастающим итогом уже не получится.

## DCity не может быть применена
* Если использовать целый контракт на платежи, при малейшем изменении, это будет затрагивать все существующие назначенные платежи.
* Не возможно добавить кастомизацию - одноразовые платежи, платежи с прочими условиями
* Если в DCity мы легко может откатить и поправить выплаты, в фондах это сделать будет значительно сложнее
