# ClaimManager

## Цель контракта

* Дать участникам возможность подать претензию на рассмотрение гуппе присяжных и получить
 компенсацию в случае положительного решения. Компенсация производится за счет депозитов
 валидаторов.

## Роли заявки
Роли валидаторов, используемые в заявках, жестко прописан в контракте ClaimManager.
Список ролей в контракте Validators, который задается вручную, должен четко ему соответствовать

* `CM_JUROR` - Валидатор жюри

## Содержание заявки
* ID токена упаковки
* Список хешей прилагаемых документов из IPFS

## Статусы заявок
* `SUBMITTED` - новая заявка, сразу после создания готова к рассмотрению валидаторами
* `APPROVED` - подтверждена
* `REVERTED` - возвращена на доработку
* `REJECTED` - отклонена

## Статусы ролей
* `PENDING` - ожидает блокировки валидатором с данной ролью
* `LOCKED` - заблокирована валидатором с данной ролью

## Действия
* `APPROVE` - одобрить
* `REJECT` - отклонить
* `REVERT` - вернуть на доработку

## Интерфейс для владельца контракта

#### setNofM()
Владелец контракта устанавливает минимальные значения для:
- N - требуемое количество голосов `за`
- M - требуемое количество валидаторов для голосования, которые могут назначится на претензию

#### #claimGaltSpaceReward()
Владелец контракта забирает свою долю комиссии, оплаченную заявителем

* Метод возможен только для заявок в статусе `APPROVED` и `REJECTED`
* Метод доступен только для заявок имеющих флаг `EXECUTED`
* В зависимости от выбранной валюты, на адрес, указанный владельцем контракта, перечисляются либо ETH либо GALT

## Интерфейс для заявителя
#### #submitClaim()
Заявитель подает заявку на возмещение ущерба

* Статус заявки устанавливается в SUBMITTED
* К заявке прилагаются IPFS хеши документов
* Указывается сумма претензии в ETH
* Указывается краткий сопроводительный текст
* Оплачивается комиссия в ETH или GALT

#### #resubmitClaim()
Заявитель повторно подает заявку на возмещение ущерба

* Метод доступен для заявок со статусом SUBMITTED
* Заново указываются:
    * IPFS хеши документов (существующие хеши перезаписываются)
    * сумма претензии в ETH (может отличаться от первоначальной)
    * Указывается краткий сопроводительный текст
* Комиссия повторно не оплачивается

* По каждому валидатору удаляются данные из
 (validator_address => struct Proposal{status: ..., payload: ...})
* Обнуляется массив адресов подавших предожения валидаторов validator_address[] 

## Интерфейс для валидаторов
#### #lock()
Валидатор блокирует за собой право на рассмотрение заявки

* Метод доступен только для заявок в статусе SUBMITTED
* Метод доступен, пока не достигнуто заблокировано M мест для работы над заявкой
* Статус заявки не меняется
* Отказаться от работы над заявкой нельзя
* Статус роли переходит в LOCKED

#### #propose()
Любой валидатор может предложить, что делать с этой заявкой.

* Возможен только для заявок SUBMITTED
* Возможен только для ролей в статусе LOCKED
* Один валидатор может предложить только одно действие - `APPROVE`, `REJECT` или `REVERT`
* В случае с `APPROVE` ожидается `merkle root hash` предполагаемых изменений (сам список хранится
 в офф-чейне, напр. в IPFS) и общая сумма сделки
* В случае с `REJECT` и `REVERT` ожидается IPFS хеш пояснения причины отказа
* В случае с `APPROVE` валидатор, который предлагает данное решение автоматически
 отдает свой голос за него
* Статусы роли и заявки не меняются

* Предложения хранятся в mapping(validator_address => struct Proposal{status: ..., payload: ...})
* Адреса валидаторов, создавших предложения кешируются в массиве validator_address[] 

#### #vote()
Валидатор голосует за какое-либо из предложений

* Метод доступен только для заявок в статусе SUBMITTED
* Метод доступен только для предложений в статусе SUBMITTED
* Метод доступен только для валидаторов в статусе LOCKED
* Один валидатор может проголосовать только за одно предложение
* Валидатор может переголосовать за другое решение, в таком случае его голос отнимается
 с предыдущего
* Если достигнуто N of M голосов, соответствующе меняется статус заявки
* Голосование останавливается.

#### #punish()
Списывается репутацию у указанного валидатора.

* Метод доступен только для заявок в статусе APPROVED
* Метод доступен только для предложений в статусе APPROVED
* Метод доступен для выполнения абсолютно любым аккаунтом (в т.ч. 3й стороной)

Метод принимает 4 аргумента:
* Адрес валидатора
* Роль
* Сумма штрафа
* Последовательный массив хешей для достижения merkle root has

* Выполняется пороверка, произведен ли штраф данной комбинации валидатор-роль-сумма. Если да, транзакция отклоняется.
* Далее они склеиваются между собой с помощью abi.encode() и от результата склейки
вычисляется keccak256 hash.
* После, полученный хеш соединяется с элементами из переданного валидаторами массивом для
достижения merkle root hash. Если вычесленный и записанный хеши не совпадают, транзакций отклоняется.
* Сумма штрафа суммируется с накопительным параметом. 
* Если общая сумма штрафа становится равной накопительному параметру, проставляется флаг `EXECUTED`, что работа
по заявке выполнена.


#### #claimValidatorReward()
Валидатор забирает свое вознаграждение

* Метод доступен только для заявок в статусе `APPROVED` и `REVERTED`
* Метод доступен только для заявок имеющих флаг `EXECUTED`
* В зависимости от типа заявки, на адрес валидатора перечисляются либо ETH либо GALT
* Поставляется флаг, что валидатор на данной роли получил вознаграждение
* Статус заявки не изменяется

## Off-chain данные предложения
Формат хранения - .yaml файл с массивом объектов
(адрес, роль, штраф в GALT):

```yaml
- address: 0x7f10a9bc17dcb92ddec11c755514e04bccd93cbf
  role: PC_CUSTODIAN_ROLE
  fine: 15
- address: 0x50d98598bae6e1dc4abda6fe654cc9a49050b9f0
  role: PC_CUSTODIAN_ROLE
  fine: 28
...
```

Для вычисление хеша используется ABI формат кодирования данных.
* address дополнительно не кодируется
* role должна быть закодирована в HEX (в первом объекте получается `0x50435f435553544f4449414e5f524f4c45000000000000000000000000000000`)
* fine добавляется 18 нулей (в первом объекте получается `15000000000000000000`)
В итоге, аргументы для первого объекта будут иметь следующий вид:
```
["0x7f10a9bc17dcb92ddec11c755514e04bccd93cbf", "0x50435f435553544f4449414e5f524f4c45000000000000000000000000000000", "15000000000000000000"]
```

JS библиотека для кодировок ABI - https://github.com/ethereumjs/ethereumjs-abi

### Предполагаемый код получения хеша
#### Solidity
```solidity
pragma solidity ^0.4.25;
pragma experimental "v0.5.0";

contract Encode {
    event Hash(bytes32);
    event Packed(bytes);

    function encode(address addr, bytes32 role, uint256 amount) public {
        bytes memory p = abi.encode(addr, role, amount);
        emit Packed(p);
        emit Hash(keccak256(p));
    }
}
```

## Сценарии

### Сценарий 1. Покупатель не может воспользоваться приобретенным участком 

1. Покупатель создает претензию на возмещения ему суммы, потраченной на покупку участка
2. 7 Валидаторов блокируют за собой право работы над заявкой
3. Валидатор #3 предлагает отклонить заявку
4. Валидатор #4 предлагает удовлетворить заявку:
    * заполняет предложение сколько с кого списать в UI
    * данные сохраняются `.yaml`/`.json`файлом в IPFS/сервере
    * UI рассчитывает merkle root hash данного предложения и он записывается в заявку
5. Валидатор #5 делает свое педложения по утверджению заявки, но с другими парами адрес-роль для списания.
 Данные о предложении записываются в заявку аналогично предыдущему пункту.Параллельно ведутся голосования валидаторов по уже созданным заявкам.
6. Предложени #3 отклонить заявку набирает 2 из 7 голосов
7. Предложени #4 удовлетворить заявку набирает 4 из 7 голосов
8. Предложени #5 удовлетворить заявку набирает 1 из 7 голосов
9. Один из проголосовавших за предложение #3 меняет свое решение и голосует за предложение #4
10. т.к. предложение #4 набирает необходимое количество голосов 5 из 7, возможность голосовать за дугие предложения блокиуется
11. Валидаторы создают аналогичное предложение в MultiSig хранящем GALT, голосуют в соответствии с принятым решением, компенсация
в GALT переводится на адрес, подавший заявку
12. Валидаторы-судья договариваются кто (не обязательно из них) производит списание средств и производят это действие
(в дальнейшем можем ввести таймаут, при достижении которого, в случае не выполнения списания репутации
со всех валидаторов-судей списывается штраф)
13. Валидаторы, чьи депозиты уменьшились, становятся не активными
14. Ставшие не активными валидаторы, которые хотят продолжить работу над заявками, пополняют свои депозиты
и становятся активным